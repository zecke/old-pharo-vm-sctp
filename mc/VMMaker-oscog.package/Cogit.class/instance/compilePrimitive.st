compile abstract instructions
compilePrimitive
	"Compile a primitive.  If possible, performance-critical primtiives will
	 be generated by their own routines (primitiveGenerator).  Otherwise,
	 if there is a primitive at all, we call the C routine with the usual
	 stack-switching dance, test the primFailCode and then either return
	 on success or continue to the method body."
	<inline: false>
	| primitiveDescriptor primitiveRoutine |
	<var: #primitiveDescriptor type: #'PrimitiveDescriptor *'>
	<var: #primitiveRoutine declareC: 'void (*primitiveRoutine)(void)'>
	primitiveIndex = 0 ifTrue: [^0].
	((primitiveDescriptor := self primitiveGeneratorOrNil) notNil
	 and: [primitiveDescriptor primitiveGenerator notNil]) ifTrue:
		["If a descriptor specifies an argument count (by numArgs >= 0)
		  then it must match for the generated code to be correct.  For
		  example for speed many primitives use ResultReceiverReg
		  instead of accessing the stack, so the receiver better be at
		  numArgs down the stack.  Use the interpreter version if not."
		 (primitiveDescriptor primNumArgs < 0 "means don't care"
		  or: [primitiveDescriptor primNumArgs = (coInterpreter argumentCountOf: methodObj)]) ifTrue:
			[^self perform: primitiveDescriptor primitiveGenerator]].
	((primitiveRoutine := coInterpreter
							functionPointerForCompiledMethod: methodObj
							primitiveIndex: primitiveIndex) isNil "no primitive"
	or: [primitiveRoutine = (coInterpreter functionPointerFor: 0 inClass: nil) "routine = primitiveFail"]) ifTrue:
		[^self genFastPrimFail].
	minValidCallAddress := minValidCallAddress min: primitiveRoutine asUnsignedInteger.
	^self compileInterpreterPrimitive: primitiveRoutine