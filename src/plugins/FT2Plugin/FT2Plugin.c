/* Automatically generated by
	FT2PluginCodeGenerator Freetype-Plugin-IgorStasenko.64 uuid: 958b30c7-6b34-4c72-ab55-507c60b6d188
   from
	FT2Plugin Freetype-Plugin-IgorStasenko.64 uuid: 958b30c7-6b34-4c72-ab55-507c60b6d188
 */
static char __buildInfo[] = "FT2Plugin Freetype-Plugin-IgorStasenko.64 uuid: 958b30c7-6b34-4c72-ab55-507c60b6d188 " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ft2build.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif

#include FT_TRUETYPE_TABLES_H
#include FT_FREETYPE_H
#include FT_OUTLINE_H
#include "sqMemoryAccess.h"


/*** Constants ***/
#define BytesPerWord 4
#define FormBitsIndex 0
#define FormDepthIndex 3
#define FormHeightIndex 2
#define FormInstSize 5
#define FormWidthIndex 1
#define FT2GlyphSlotFaceIndex 0
#define FT2GlyphSlotInstSize 17
#define FT2OutlineContoursIndex 4
#define FT2OutlineContoursSizeIndex 0
#define FT2OutlineInstSize 5
#define FT2OutlinePointsIndex 2
#define FT2OutlinePointsSizeIndex 1
#define FT2OutlineTagsIndex 3


/*** Function Prototypes ***/
static char * fetchByteArrayofObjectassureSize(sqInt fieldIndex, sqInt objectPointer, sqInt aSize);
static short* fetchShortArrayofObjectassureSize(sqInt fieldIndex, sqInt objectPointer, sqInt aSize);
static long * fetchWordArrayofObjectassureSize(sqInt fieldIndex, sqInt objectPointer, sqInt aSize);
static sqInt ftAllocateHandleInReceiverForPointer(void *aPointer);
static sqInt ftAllocateStringForPointer(const char *aPointer);
static FT_Encoding ftEncodingValueFromString(sqInt string);
static void * ftHandleValueFromReceiver(sqInt rcvrOop);
static int ftInitBitmapfromForm(FT_Bitmap*bitmap, sqInt formOop);
static int ftInitBitmapfromFormrenderMode(FT_Bitmap*bitmap, sqInt formOop, sqInt mode);
static int ftParameterError(void);
static sqInt ftStringFromEncodingValue(FT_Encoding encoding);
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt msg(char *s);
EXPORT(sqInt) primitiveCopyToExternalMemory(void);
EXPORT(sqInt) primitiveDoneFace(void);
EXPORT(sqInt) primitiveDoneFacePreserveFields(void);
EXPORT(sqInt) primitiveEmboldenFaceGlyphSlotOutline(void);
EXPORT(sqInt) primitiveErrorCode(void);
EXPORT(sqInt) primitiveErrorString(void);
EXPORT(sqInt) primitiveFreeExternalMemory(void);
EXPORT(sqInt) primitiveGetFaceCharIndex(void);
EXPORT(sqInt) primitiveGetFaceCharMap(void);
EXPORT(sqInt) primitiveGetFaceCharMapsIntoArray(void);
EXPORT(sqInt) primitiveGetFaceGlyphName(void);
EXPORT(sqInt) primitiveGetKerningLeftRight(void);
EXPORT(sqInt) primitiveGetPostscriptName(void);
EXPORT(sqInt) primitiveGetSfntTableOS2(void);
static sqInt primitiveGetTrackKerningPointSizedegree(sqInt pointSize, sqInt degree);
EXPORT(sqInt) primitiveHasKerning(void);
EXPORT(sqInt) primitiveLibraryHandle(void);
EXPORT(sqInt) primitiveLoadCharacter(void);
EXPORT(sqInt) primitiveLoadFaceBbox(void);
EXPORT(sqInt) primitiveLoadFaceFields(void);
EXPORT(sqInt) primitiveLoadGlyph(void);
EXPORT(sqInt) primitiveLoadGlyphSlotFromFace(void);
EXPORT(sqInt) primitiveLoadOutlineArraysFromFace(void);
EXPORT(sqInt) primitiveLoadOutlineSizesFromFace(void);
EXPORT(sqInt) primitiveModuleErrorCode(void);
EXPORT(sqInt) primitiveNewFaceFromFileAndIndex(void);
EXPORT(sqInt) primitiveNewMemoryFaceFromExternalMemoryAndIndex(void);
EXPORT(sqInt) primitiveNumberOfOutlineCountours(void);
EXPORT(sqInt) primitiveRenderGlyphIntoForm(void);
EXPORT(sqInt) primitiveRenderGlyphIntoFormWithRenderMode(void);
EXPORT(sqInt) primitiveResetErrorCode(void);
EXPORT(sqInt) primitiveSetFaceCharMap(void);
EXPORT(sqInt) primitiveSetPixelSizes(void);
EXPORT(sqInt) primitiveSetTransform(void);
EXPORT(sqInt) primitiveTransformFaceGlyphSlotOutline(void);
EXPORT(sqInt) primitiveTranslateFaceGlyphSlotOutline(void);
EXPORT(sqInt) primitiveVersion(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
EXPORT(sqInt) shutdownModule(void);
static void sqAssert(sqInt aBool);


/*** Variables ***/
static int errorCode;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*arrayValueOf)(sqInt oop);
static sqInt (*byteSizeOf)(sqInt oop);
static sqInt (*classByteArray)(void);
static sqInt (*classString)(void);
static sqInt (*failed)(void);
static void * (*fetchArrayofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchIntegerofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
static sqInt (*integerObjectOf)(sqInt value);
static sqInt (*ioFilenamefromStringofLengthresolveAliases)(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static sqInt (*isKindOf)(sqInt oop, char *aString);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*isIndexable)(sqInt oop);
static sqInt (*isIntegerObject)(sqInt objectPointer);
static sqInt (*isPointers)(sqInt oop);
static sqInt (*isWords)(sqInt oop);
static sqInt (*makePointwithxValueyValue)(sqInt xValue, sqInt yValue);
static sqInt (*methodArgumentCount)(void);
static sqInt (*nilObject)(void);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(sqInt integerValue);
static sqInt (*primitiveFail)(void);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storeIntegerofObjectwithValue)(sqInt index, sqInt oop, sqInt integer);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*success)(sqInt aBoolean);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * arrayValueOf(sqInt oop);
extern sqInt byteSizeOf(sqInt oop);
extern sqInt classByteArray(void);
extern sqInt classString(void);
extern sqInt failed(void);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
extern sqInt integerObjectOf(sqInt value);
extern sqInt ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
extern sqInt isKindOf(sqInt oop, char *aString);
extern sqInt isBytes(sqInt oop);
extern sqInt isIndexable(sqInt oop);
extern sqInt isIntegerObject(sqInt objectPointer);
extern sqInt isPointers(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
extern sqInt methodArgumentCount(void);
extern sqInt nilObject(void);
extern sqInt pop(sqInt nItems);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(sqInt integerValue);
extern sqInt primitiveFail(void);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storeIntegerofObjectwithValue(sqInt index, sqInt oop, sqInt integer);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt success(sqInt aBoolean);

extern
#endif
struct VirtualMachine* interpreterProxy;
static FT_Library library;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"FT2Plugin Freetype-Plugin-IgorStasenko.64 (i)"
#else
	"FT2Plugin Freetype-Plugin-IgorStasenko.64 (e)"
#endif
;


static char *
fetchByteArrayofObjectassureSize(sqInt fieldIndex, sqInt objectPointer, sqInt aSize)
{
	// FT2Plugin>>#fetchByteArray:ofObject:assureSize:
	sqInt array;

	array = fetchPointerofObject(fieldIndex, objectPointer);
	if ((isBytes(array))
	 && ((slotSizeOf(array)) == aSize)) {
		return arrayValueOf(array);
	}
	return null;
}

static short*
fetchShortArrayofObjectassureSize(sqInt fieldIndex, sqInt objectPointer, sqInt aSize)
{
	// FT2Plugin>>#fetchShortArray:ofObject:assureSize:
	sqInt array;

	array = fetchPointerofObject(fieldIndex, objectPointer);
	if ((isWords(array))
	 && ((slotSizeOf(array)) == (((sqInt) (aSize + 1) >> 1)))) {
		return arrayValueOf(array);
	}
	return null;
}

static long *
fetchWordArrayofObjectassureSize(sqInt fieldIndex, sqInt objectPointer, sqInt aSize)
{
	// FT2Plugin>>#fetchWordArray:ofObject:assureSize:
	sqInt array;

	array = fetchPointerofObject(fieldIndex, objectPointer);
	if ((isWords(array))
	 && ((slotSizeOf(array)) == aSize)) {
		return arrayValueOf(array);
	}
	return null;
}


/*	given aPointer (returned from a library call),
	set the receiver's (bottom of stack) first instance variable
	to a ByteArray containing the pointer's bytes */

static sqInt
ftAllocateHandleInReceiverForPointer(void *aPointer)
{
	// FT2Plugin>>#ftAllocateHandleInReceiverForPointer:
	void **extraByteArrayPtr;
	sqInt returnedHandle;

	if (aPointer) {

		/* Allocate a Smalltalk ByteArray -- lastAlloc contains the length */
		/* Copy from the C bytecode buffer to the Smalltalk ByteArray */


		/* Allocate a Smalltalk ByteArray -- lastAlloc contains the length */
		/* Copy from the C bytecode buffer to the Smalltalk ByteArray */

returnedHandle = instantiateClassindexableSize(classByteArray(), sizeof(void **));
		extraByteArrayPtr = arrayValueOf(returnedHandle);
		*extraByteArrayPtr = (void *)(aPointer);
	}
	else {
returnedHandle = nilObject();
	}
	storePointerofObjectwithValue(0, stackObjectValue(methodArgumentCount()), returnedHandle);
	;
	return returnedHandle;
}


/*	given NUL-terminated char* aPointer (returned from a library call), 
	return the oop for a String containing the pointer's bytes */

static sqInt
ftAllocateStringForPointer(const char *aPointer)
{
	// FT2Plugin>>#ftAllocateStringForPointer:
	char *extraByteArrayPtr;
	sqInt returnedHandle;

	if (aPointer) {

		/* Allocate a Smalltalk ByteArray -- lastAlloc contains the length */
		/* Copy from the C bytecode buffer to the Smalltalk ByteArray */


		/* Allocate a Smalltalk ByteArray -- lastAlloc contains the length */
		/* Copy from the C bytecode buffer to the Smalltalk ByteArray */

returnedHandle = instantiateClassindexableSize(classString(), strlen(aPointer));
		extraByteArrayPtr = arrayValueOf(returnedHandle);
		;
		strncpy(extraByteArrayPtr, aPointer, strlen(aPointer));
	}
	else {
returnedHandle = nilObject();
	}
	return returnedHandle;
}


/*	Return a 32-bit word from the bytes held by string. */

static FT_Encoding
ftEncodingValueFromString(sqInt string)
{
	// FT2Plugin>>#ftEncodingValueFromString:
	unsigned char*ptr;
	unsigned long retval;

	success((!(isIntegerObject(string)))
	 && ((isBytes(string))
	 && ((slotSizeOf(string)) == (sizeof(FT_Encoding)))));
	if (failed()) {
		return null;
	}
	retval = 0;

	/* ptr := self cCode: '(unsigned char *) (string + 4)'. */

ptr = arrayValueOf(string);
	;
	retval = ((unsigned long)ptr[0]) << 24;
	retval += ((unsigned long)ptr[1]) << 16;
	retval += ((unsigned long)ptr[2]) << 8;
	retval += (unsigned long)ptr[3];
	;
	return (FT_Encoding)retval;
}


/*	this is the opposite of #ftAllocateHandleIn:forPointer: .
	It takes rcvr's first instance variable,
	which should be a ByteArray the size of a void*,
	and returns its value as a C pointer. */

static void *
ftHandleValueFromReceiver(sqInt rcvrOop)
{
	// FT2Plugin>>#ftHandleValueFromReceiver:
	sqInt btw;
	sqInt oop;

	oop = fetchPointerofObject(0, rcvrOop);
	success((isBytes(oop))
	 && ((slotSizeOf(oop)) == (sizeof(void *))));
	if (failed()) {
		return null;
	}
	btw = BytesPerWord;
	return *(void**)(pointerForOop(oop + btw));
}


/*	Initialize the values in an FT_Bitmap from the given Form */

static int
ftInitBitmapfromForm(FT_Bitmap*bitmap, sqInt formOop)
{
	// FT2Plugin>>#ftInitBitmap:fromForm:
	unsigned char*buffer;
	sqInt depth;
	sqInt height;
	sqInt numGrays;
	sqInt pitch;
	sqInt pixelMode;
	sqInt width;
	sqInt wordsPerRow;

	success(isPointers(formOop));
	success((slotSizeOf(formOop)) >= FormInstSize);
	if (failed()) {
		return null;
	}
	width = fetchIntegerofObject(FormWidthIndex, formOop);
	height = fetchIntegerofObject(FormHeightIndex, formOop);
	depth = fetchIntegerofObject(FormDepthIndex, formOop);
	buffer = ((void*) (fetchArrayofObject(FormBitsIndex, formOop)));
	if (failed()) {
		return null;
	}
	if (depth < 0) {
depth = depth * -1;
	}
	if (depth == 1) {
wordsPerRow = ((sqInt) (width + 31) >> 5);
		numGrays = 1;
		pixelMode = FT_PIXEL_MODE_MONO;
	}
	else {
if (depth == 8) {
wordsPerRow = ((sqInt) (width + 3) >> 2);
			numGrays = 256;
			pixelMode = FT_PIXEL_MODE_GRAY;
		}
		else {
return primitiveFail();
		}
	}
	
#ifndef WORDS_BIGENDIAN
depth = depth * -1;
#endif
;
	storeIntegerofObjectwithValue(FormDepthIndex, formOop, depth);
	pitch = wordsPerRow * 4;
	bitmap->rows = height;
	bitmap->width = width;
	bitmap->pitch = pitch;
	bitmap->buffer = buffer;
	bitmap->num_grays = numGrays;
	bitmap->pixel_mode = pixelMode;
	return 1;
}


/*	Initialize the values in an FT_Bitmap from the given Form */
/*	pixelMode */

static int
ftInitBitmapfromFormrenderMode(FT_Bitmap*bitmap, sqInt formOop, sqInt mode)
{
	// FT2Plugin>>#ftInitBitmap:fromForm:renderMode:
	unsigned char*buffer;
	sqInt depth;
	sqInt height;
	sqInt numGrays;
	sqInt pitch;
	sqInt width;
	sqInt wordsPerRow;

	success(isPointers(formOop));
	success((slotSizeOf(formOop)) >= FormInstSize);
	if (failed()) {
		return null;
	}
	width = fetchIntegerofObject(FormWidthIndex, formOop);
	height = fetchIntegerofObject(FormHeightIndex, formOop);
	depth = fetchIntegerofObject(FormDepthIndex, formOop);
	buffer = ((void*) (fetchArrayofObject(FormBitsIndex, formOop)));
	if (failed()) {
		return null;
	}
	if (depth < 0) {
depth = depth * -1;
	}
	if (depth == 1) {
wordsPerRow = ((sqInt) (width + 31) >> 5);
		numGrays = 1;
	}
	else {
if (depth == 8) {
wordsPerRow = ((sqInt) (width + 3) >> 2);
			numGrays = 256;
		}
		else {
return primitiveFail();
		}
	}
	
#ifndef WORDS_BIGENDIAN
depth = depth * -1;
#endif
;
	storeIntegerofObjectwithValue(FormDepthIndex, formOop, depth);
	pitch = wordsPerRow * 4;
	bitmap->rows = height;
	bitmap->width = width;
	bitmap->pitch = pitch;
	bitmap->buffer = buffer;
	bitmap->num_grays = numGrays;
	bitmap->pixel_mode = mode;
	return 1;
}

static int
ftParameterError(void)
{
	// FT2Plugin>>#ftParameterError
	errorCode = 255;
	return primitiveFail();
}


/*	Return a newly allocated String from the given 32-bit word */

static sqInt
ftStringFromEncodingValue(FT_Encoding encoding)
{
	// FT2Plugin>>#ftStringFromEncodingValue:
	unsigned char*ptr;
	sqInt stringOop;

	stringOop = instantiateClassindexableSize(classString(), sizeof(FT_Encoding));
	;
	if (failed()) {
		return null;
	}
	ptr = firstIndexableField(stringOop);
	;
	ptr[0] = (encoding & 0xFF000000) >> 24;
	ptr[1] = (encoding & 0x00FF0000) >> 16;
	ptr[2] = (encoding & 0x0000FF00) >> 8;
	ptr[3] = (encoding & 0x000000FF);
	return stringOop;
}


/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void)
{
	// InterpreterPlugin>>#getInterpreter
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void)
{
	// InterpreterPlugin>>#getModuleName
	return moduleName;
}

static sqInt
halt(void)
{
	// InterpreterPlugin>>#halt
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void)
{
	// FT2Plugin>>#initialiseModule

	/* not implemented?? commented out because of compilation errors
	   
	   self ifDefined: 'macintoshSqueak' then: [
	   self fetchPreferences.
	   ].
	    */

	library = null;
	errorCode = FT_Init_FreeType(&library);
	return errorCode == 0;
}

static sqInt
msg(char *s)
{
	// InterpreterPlugin>>#msg:
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}

EXPORT(sqInt)
primitiveCopyToExternalMemory(void)
{
	// FT2Plugin>>#primitiveCopyToExternalMemory
	char *aByteArray;
	void *aPointer;
	size_t byteSize;
	sqInt rcvr;

	success(isBytes(stackValue(0)));
	aByteArray = ((char *) (firstIndexableField(stackValue(0))));
	success(isKindOf(stackValue(1), "FreeTypeExternalMemory"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	;
	errorCode = 0;
	byteSize = byteSizeOf(((sqInt)(long)(aByteArray) - 4));
	;
	if (failed()) {
		return null;
	}
	aPointer = malloc(byteSize);
	memcpy(aPointer,aByteArray,byteSize);
	ftAllocateHandleInReceiverForPointer(aPointer);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}


/*	Call the library to release the given face record.
	Nil out the pointer fields */

EXPORT(sqInt)
primitiveDoneFace(void)
{
	// FT2Plugin>>#primitiveDoneFace
	FT_Face face;
	sqInt i;
	sqInt rcvr;

	success(isKindOf(stackValue(0), "FT2Face"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	;

	/* nil out all the fields */

errorCode = FT_Done_Face(face);
	for (i = 0; i <= 23; i += 1) {
storePointerofObjectwithValue(i, rcvr, nilObject());
	}
	success(errorCode == 0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	return null;
}


/*	Call the library to release the given face record.
	Nil out the handle field, but do not nil the other fields,
	as their values are needed even if the face cannot be re-opened
	in the future due to a missing font file etc. */

EXPORT(sqInt)
primitiveDoneFacePreserveFields(void)
{
	// FT2Plugin>>#primitiveDoneFacePreserveFields
	FT_Face face;
	sqInt rcvr;

	success(isKindOf(stackValue(0), "FT2Face"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	;

	/* nil the handle field */

errorCode = FT_Done_Face(face);
	storePointerofObjectwithValue(0, rcvr, nilObject());
	success(errorCode == 0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	return null;
}


/*	emboldens the outline in the face's glyphSlot by strength (expressed in
	26.6 pixel format).
	The new outline will be at most 4 times `strength' pixels wider and
	higher. 
 */

EXPORT(sqInt)
primitiveEmboldenFaceGlyphSlotOutline(void)
{
	// FT2Plugin>>#primitiveEmboldenFaceGlyphSlotOutline
	FT_Face face;
	sqInt rcvr;
	sqInt strength;

	strength = stackIntegerValue(0);
	success(isKindOf(stackValue(1), "FT2Face"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	errorCode = FT_Outline_Embolden( &face->glyph->outline, strength );
	success(errorCode == 0);
	if (failed()) {
		return null;
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}


/*	high byte is module error, low is generic error */

EXPORT(sqInt)
primitiveErrorCode(void)
{
	// FT2Plugin>>#primitiveErrorCode
	sqInt _return_value;

	_return_value = positive32BitIntegerFor((FT_ERROR_BASE(errorCode)));
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}

EXPORT(sqInt)
primitiveErrorString(void)
{
	// FT2Plugin>>#primitiveErrorString
	const struct ftError *ftError;
	const char *str;

	
struct ftError { int errCode; const char* errMsg; };
#undef __FTERRORS_H__
#define FT_ERRORDEF( e, v, s )  { e, s },
#define FT_ERROR_START_LIST     {
#define FT_ERROR_END_LIST       { 0xFF, "Bad Squeak Method Parameter" }, { 0, NULL } };
static const struct ftError ftErrors[] =
#include FT_ERRORS_H
;
	ftError = ftErrors;
	;
	while (((str = ftError->errMsg))
	 && (FT_ERROR_BASE(errorCode) != ftError->errCode)) {
		ftError++;
	}
;
	if (!str) {
success(0);
	}
	if (failed()) {
		return null;
	}
	popthenPush(1, ftAllocateStringForPointer(str));
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	return null;
}

EXPORT(sqInt)
primitiveFreeExternalMemory(void)
{
	// FT2Plugin>>#primitiveFreeExternalMemory
	void*memPointer;
	sqInt rcvr;

	success(isKindOf(stackValue(0), "FreeTypeExternalMemory"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	;

	/* free the memory handle */

errorCode = 0;
	memPointer = ftHandleValueFromReceiver(rcvr);
	if (!(memPointer == null)) {
		free(memPointer);
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	return null;
}


/*	Return the Freetype glyph index of the given character code, in the 
	current encoding. 
	Return value of 0 means 'undefined character code'. */

EXPORT(sqInt)
primitiveGetFaceCharIndex(void)
{
	// FT2Plugin>>#primitiveGetFaceCharIndex
	sqInt charIndex;
	FT_Face face;
	sqInt rcvr;
	sqInt result;
	sqInt _return_value;

	charIndex = stackIntegerValue(0);
	success(isKindOf(stackValue(1), "FT2Face"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	errorCode = 0;
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	result = FT_Get_Char_Index(face, charIndex);
	_return_value = positive32BitIntegerFor(result);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

EXPORT(sqInt)
primitiveGetFaceCharMap(void)
{
	// FT2Plugin>>#primitiveGetFaceCharMap
	FT_CharMap charmap;
	FT_Encoding encoding;
	FT_Face face;
	sqInt rcvr;
	sqInt stringOop;

	success(isKindOf(stackValue(0), "FT2Face"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	charmap = face->charmap;
	if (!charmap) {
return null;
	}
	pushRemappableOop(rcvr);
	encoding = charmap->encoding;
	stringOop = ftStringFromEncodingValue(encoding);
	rcvr = popRemappableOop();
	storePointerofObjectwithValue(22, rcvr, stringOop);
	storeIntegerofObjectwithValue(23, rcvr, charmap->platform_id);
	storeIntegerofObjectwithValue(24, rcvr, charmap->encoding_id);
	if (failed()) {
		return null;
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	return null;
}

EXPORT(sqInt)
primitiveGetFaceCharMapsIntoArray(void)
{
	// FT2Plugin>>#primitiveGetFaceCharMapsIntoArray
	sqInt *array;
	sqInt arrayOop;
	FT_CharMap *charmap;
	FT_Face face;
	sqInt i;
	int numCharmaps;
	sqInt rcvr;
	sqInt stringOop;

	success(isIndexable(stackValue(0)));
	array = ((int *) (firstIndexableField(stackValue(0))));
	success(isKindOf(stackValue(1), "FT2Face"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	numCharmaps = face->num_charmaps;
	arrayOop = ((int) array) - 4;
	success((slotSizeOf(arrayOop)) == numCharmaps);
	if (failed()) {
		return null;
	}
	charmap = face->charmaps;
	;
	for (i = 0; i <= (numCharmaps - 1); i += 1) {
		pushRemappableOop(arrayOop);
		stringOop = ftStringFromEncodingValue((*charmap)->encoding);
		arrayOop = popRemappableOop();
		storePointerofObjectwithValue(i, arrayOop, stringOop);
		charmap++;
	}
	if (failed()) {
		return null;
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}


/*	return a String */

EXPORT(sqInt)
primitiveGetFaceGlyphName(void)
{
	// FT2Plugin>>#primitiveGetFaceGlyphName
	char buffer[100];
	FT_Face face;
	sqInt glyphIndex;
	sqInt rcvr;
	sqInt string;

	glyphIndex = stackIntegerValue(0);
	success(isKindOf(stackValue(1), "FT2Face"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	errorCode = FT_Get_Glyph_Name(face, glyphIndex, buffer, 100);
	success(errorCode == 0);
	if (failed()) {
		return null;
	}
	string = ftAllocateStringForPointer(buffer);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(2, string);
	return null;
}

EXPORT(sqInt)
primitiveGetKerningLeftRight(void)
{
	// FT2Plugin>>#primitiveGetKerningLeftRight
	FT_Face face;
	sqInt kernMode;
	sqInt leftGlyph;
	sqInt pointOop;
	sqInt rcvr;
	FT_Vector result;
	sqInt rightGlyph;

	leftGlyph = stackIntegerValue(1);
	rightGlyph = stackIntegerValue(0);
	
		result.x=3;
		result.y=4;;
	;
	success(isKindOf(stackValue(2), "FT2Face"));
	rcvr = stackValue(2);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	errorCode = 0;
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	kernMode = FT_KERNING_UNSCALED;
	;
	FT_Get_Kerning(face, leftGlyph, rightGlyph, kernMode, &result);;
	pointOop = makePointwithxValueyValue(result.x, result.y);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(3, pointOop);
	return null;
}


/*	return a String */

EXPORT(sqInt)
primitiveGetPostscriptName(void)
{
	// FT2Plugin>>#primitiveGetPostscriptName
	char*buffer;
	FT_Face face;
	sqInt rcvr;
	sqInt string;

	success(isKindOf(stackValue(0), "FT2Face"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	buffer = 0;
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	buffer = FT_Get_Postscript_Name(face);
	success(buffer != 0);
	if (failed()) {
		return null;
	}
	string = ftAllocateStringForPointer(buffer);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(1, string);
	return null;
}


/*	return the bytes from the OS/2 table */

EXPORT(sqInt)
primitiveGetSfntTableOS2(void)
{
	// FT2Plugin>>#primitiveGetSfntTableOS2
	char *buffer;
	char *extraByteArrayPtr;
	FT_Face face;
	sqInt rcvr;
	sqInt returnedHandle;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "FT2Face"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	buffer = 0;
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	buffer = FT_Get_Sfnt_Table(face,ft_sfnt_os2);
	if (buffer == 0) {
_return_value = integerObjectOf(-1);
		if (failed()) {
			/* begin ftParameterError */
errorCode = 255;
			primitiveFail();
			return null;
		}
		popthenPush(1, _return_value);
		return null;
	}

	/* Copy from the C bytecode buffer to the Smalltalk ByteArray */

returnedHandle = instantiateClassindexableSize(classByteArray(), sizeof(TT_OS2));
	extraByteArrayPtr = arrayValueOf(returnedHandle);
	;
	memcpy(extraByteArrayPtr, buffer, sizeof(TT_OS2));
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(1, returnedHandle);
	return null;
}


/*	disabled becaus of yet implemented */

static sqInt
primitiveGetTrackKerningPointSizedegree(sqInt pointSize, sqInt degree)
{
	// FT2Plugin>>#primitiveGetTrackKerningPointSize:degree:
	return primitiveFail();
}

EXPORT(sqInt)
primitiveHasKerning(void)
{
	// FT2Plugin>>#primitiveHasKerning
	FT_Face face;
	sqInt rcvr;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "FT2Face"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	errorCode = 0;
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	_return_value = integerObjectOf(FT_HAS_KERNING( face ));
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}


/*	Fill in the handle in an FT2Library structure with a copy of our global
	pointer. 
 */

EXPORT(sqInt)
primitiveLibraryHandle(void)
{
	// FT2Plugin>>#primitiveLibraryHandle
	sqInt rcvr;

	success(isKindOf(stackValue(0), "FT2Library"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	errorCode = 0;
	ftAllocateHandleInReceiverForPointer(library);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	return null;
}


/*	Load the glyph at the given index in the current charmap.
	The default map upon opening a font is the 'unic' or Unicode charmap, if
	any. 
 */

EXPORT(sqInt)
primitiveLoadCharacter(void)
{
	// FT2Plugin>>#primitiveLoadCharacter
	FT_Face face;
	sqInt flags;
	sqInt index;
	sqInt rcvr;

	index = stackIntegerValue(1);
	flags = stackIntegerValue(0);
	success(isKindOf(stackValue(2), "FT2Face"));
	rcvr = stackValue(2);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	errorCode = FT_Load_Char(face, index, flags);
	success(errorCode == 0);
	if (failed()) {
		return null;
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(2);
	return null;
}

EXPORT(sqInt)
primitiveLoadFaceBbox(void)
{
	// FT2Plugin>>#primitiveLoadFaceBbox
	sqInt aRectangle;
	FT_Face face;
	sqInt pointOop;
	sqInt rcvr;
	sqInt rectOop;

	success(isKindOf(stackValue(0), "Rectangle"));
	aRectangle = stackValue(0);
	success(isKindOf(stackValue(1), "FT2Face"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	rectOop = aRectangle;
	if (!(isPointers(rectOop))) {
		primitiveFail();
		return null;
	}
	if ((slotSizeOf(rectOop)) < 2) {
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	;
	if (!(face->face_flags & FT_FACE_FLAG_SCALABLE)) {
		success(0);
	}
	if (failed()) {
		return null;
	}
	pushRemappableOop(rectOop);
	pointOop = makePointwithxValueyValue(face->bbox.xMin, face->bbox.yMin);
	rectOop = popRemappableOop();
	storePointerofObjectwithValue(0, rectOop, pointOop);
	pushRemappableOop(rectOop);
	pointOop = makePointwithxValueyValue(face->bbox.xMax, face->bbox.yMax);
	rectOop = popRemappableOop();
	storePointerofObjectwithValue(1, rectOop, pointOop);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}


/*	Fill in many of the receiver's (an FT2Face) fields (other than its handle)
	from the FT_Face record that it points to. */

EXPORT(sqInt)
primitiveLoadFaceFields(void)
{
	// FT2Plugin>>#primitiveLoadFaceFields
	FT_Face face;
	sqInt rcvr;
	sqInt strOop;

	success(isKindOf(stackValue(0), "FT2Face"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	;
	storeIntegerofObjectwithValue(1, rcvr, face->num_faces);
	storeIntegerofObjectwithValue(2, rcvr, face->face_index);
	storeIntegerofObjectwithValue(3, rcvr, face->face_flags);
	storeIntegerofObjectwithValue(4, rcvr, face->style_flags);
	storeIntegerofObjectwithValue(5, rcvr, face->num_glyphs);
	pushRemappableOop(rcvr);
	strOop = ftAllocateStringForPointer(face->family_name);
	rcvr = popRemappableOop();
	storePointerofObjectwithValue(6, rcvr, strOop);
	pushRemappableOop(rcvr);
	strOop = ftAllocateStringForPointer(face->style_name);
	rcvr = popRemappableOop();
	storePointerofObjectwithValue(7, rcvr, strOop);
	storeIntegerofObjectwithValue(8, rcvr, face->num_fixed_sizes);
	storeIntegerofObjectwithValue(10, rcvr, face->num_charmaps);
	if (face->face_flags & FT_FACE_FLAG_SCALABLE) {

		/* bbox -- Rectangle xMin, yMin, xMax, yMax */
		/* unitsPerEm */
		/* ascender */

storeIntegerofObjectwithValue(13, rcvr, face->units_per_EM);
		storeIntegerofObjectwithValue(14, rcvr, face->ascender);
		storeIntegerofObjectwithValue(15, rcvr, face->descender);
		storeIntegerofObjectwithValue(16, rcvr, face->height);
		storeIntegerofObjectwithValue(17, rcvr, face->max_advance_width);
		storeIntegerofObjectwithValue(18, rcvr, face->max_advance_height);
		storeIntegerofObjectwithValue(19, rcvr, face->underline_position);
		storeIntegerofObjectwithValue(20, rcvr, face->underline_thickness);
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	return null;
}

EXPORT(sqInt)
primitiveLoadGlyph(void)
{
	// FT2Plugin>>#primitiveLoadGlyph
	FT_Face face;
	sqInt flags;
	sqInt index;
	sqInt rcvr;

	index = stackIntegerValue(1);
	flags = stackIntegerValue(0);
	success(isKindOf(stackValue(2), "FT2Face"));
	rcvr = stackValue(2);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	errorCode = FT_Load_Glyph(face, index, flags);
	success(errorCode == 0);
	if (failed()) {
		return null;
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(2);
	return null;
}


/*	Assumes that primitiveLoadGlyph:flags: has been called earlier to set
	face->glyph. 
 */

EXPORT(sqInt)
primitiveLoadGlyphSlotFromFace(void)
{
	// FT2Plugin>>#primitiveLoadGlyphSlotFromFace
	sqInt aFace;
	sqInt btw;
	FT_Face face;
	sqInt gfOop;
	FT_Glyph_Format *gfPtr;
	FT_GlyphSlot gs;
	sqInt rcvr;

	success(isKindOf(stackValue(0), "FT2Face"));
	aFace = stackValue(0);
	success(isKindOf(stackValue(1), "FT2GlyphSlot"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	errorCode = 0;
	if ((slotSizeOf(rcvr)) < 8) {
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(aFace);
	if (face == null) {
primitiveFail();
		return null;
	}
	gs = face->glyph;
	if (!gs) {
primitiveFail();
		return null;
	}
	;
	storePointerofObjectwithValue(0, rcvr, aFace);
	storeIntegerofObjectwithValue(1, rcvr, gs->linearHoriAdvance);
	storeIntegerofObjectwithValue(2, rcvr, gs->linearVertAdvance);
	storeIntegerofObjectwithValue(3, rcvr, gs->advance.x);
	storeIntegerofObjectwithValue(4, rcvr, gs->advance.y);
	pushRemappableOop(rcvr);
	gfOop = instantiateClassindexableSize(classByteArray(), sizeof(FT_Glyph_Format));
	;
	btw = BytesPerWord;
	gfPtr = (FT_Glyph_Format *) pointerForOop(gfOop + btw);
	;
	if (failed()) {
		return null;
	}
	*gfPtr = gs->format;
	rcvr = popRemappableOop();
	storePointerofObjectwithValue(5, rcvr, gfOop);
	storeIntegerofObjectwithValue(6, rcvr, gs->bitmap_left);
	storeIntegerofObjectwithValue(7, rcvr, gs->bitmap_top);
	storeIntegerofObjectwithValue(8, rcvr, gs->metrics.width);
	storeIntegerofObjectwithValue(9, rcvr, gs->metrics.height);
	storeIntegerofObjectwithValue(10, rcvr, gs->metrics.horiBearingX);
	storeIntegerofObjectwithValue(11, rcvr, gs->metrics.horiBearingY);
	storeIntegerofObjectwithValue(12, rcvr, gs->metrics.horiAdvance);
	storeIntegerofObjectwithValue(13, rcvr, gs->metrics.vertBearingX);
	storeIntegerofObjectwithValue(14, rcvr, gs->metrics.vertBearingY);
	storeIntegerofObjectwithValue(15, rcvr, gs->metrics.vertAdvance);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}


/*	Assumes that primitiveLoadGlyph:flags: has been called earlier to set
	face->glyph. 
 */

EXPORT(sqInt)
primitiveLoadOutlineArraysFromFace(void)
{
	// FT2Plugin>>#primitiveLoadOutlineArraysFromFace
	sqInt aFace;
	sqInt array;
	sqInt array1;
	sqInt array2;
	short *contours;
	sqInt contoursSize;
	FT_Face face;
	FT_GlyphSlot gs;
	sqInt i;
	long *points;
	sqInt pointsSize;
	sqInt rcvr;
	char*tags;


	/* ptr to struct */
	/* ptr to struct */

success(isKindOf(stackValue(0), "FT2Face"));
	aFace = stackValue(0);
	success(isKindOf(stackValue(1), "FT2Outline"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	errorCode = 0;
	if ((slotSizeOf(rcvr)) < FT2OutlineInstSize) {
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(aFace);
	if (face == null) {
primitiveFail();
		return null;
	}
	gs = face->glyph;
	if (!gs) {
primitiveFail();
		return null;
	}
	;
	pointsSize = gs->outline.n_points;
	/* begin fetchWordArray:ofObject:assureSize: */
array = fetchPointerofObject(FT2OutlinePointsIndex, rcvr);
	if ((isWords(array))
	 && ((slotSizeOf(array)) == (pointsSize * 2))) {
		points = arrayValueOf(array);
		goto l1;
	}
	points = null;
l1:	/* end fetchWordArray:ofObject:assureSize: */;
	if (points == null) {
primitiveFail();
		return null;
	}
	/* begin fetchByteArray:ofObject:assureSize: */
array1 = fetchPointerofObject(FT2OutlineTagsIndex, rcvr);
	if ((isBytes(array1))
	 && ((slotSizeOf(array1)) == pointsSize)) {
		tags = ((char *) (arrayValueOf(array1)));
		goto l2;
	}
	tags = ((char *) null);
l2:	/* end fetchByteArray:ofObject:assureSize: */;
	if (tags == null) {
primitiveFail();
		return null;
	}
	for (i = 0; i <= (pointsSize - 1); i += 1) {
		points[2 * i] = (gs->outline.points[i].x);
		points[(2 * i) + 1] = (gs->outline.points[i].y);
		tags[i] = (gs->outline.tags[i]);
	}
	contoursSize = gs->outline.n_contours;
	/* begin fetchShortArray:ofObject:assureSize: */
array2 = fetchPointerofObject(FT2OutlineContoursIndex, rcvr);
	if ((isWords(array2))
	 && ((slotSizeOf(array2)) == (((sqInt) (contoursSize + 1) >> 1)))) {
		contours = ((short*) (arrayValueOf(array2)));
		goto l3;
	}
	contours = ((short*) null);
l3:	/* end fetchShortArray:ofObject:assureSize: */;
	for (i = 0; i <= (contoursSize - 1); i += 1) {
		contours[i] = (gs->outline.contours[i]);
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}


/*	Assumes that primitiveLoadGlyph:flags: has been called earlier to set
	face->glyph. 
 */

EXPORT(sqInt)
primitiveLoadOutlineSizesFromFace(void)
{
	// FT2Plugin>>#primitiveLoadOutlineSizesFromFace
	sqInt aFace;
	FT_Face face;
	FT_GlyphSlot gs;
	sqInt rcvr;

	success(isKindOf(stackValue(0), "FT2Face"));
	aFace = stackValue(0);
	success(isKindOf(stackValue(1), "FT2Outline"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	errorCode = 0;
	if ((slotSizeOf(rcvr)) < FT2OutlineInstSize) {
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(aFace);
	if (face == null) {
primitiveFail();
		return null;
	}
	gs = face->glyph;
	if (!gs) {
primitiveFail();
		return null;
	}
	;
	storeIntegerofObjectwithValue(FT2OutlineContoursSizeIndex, rcvr, gs->outline.n_contours);
	storeIntegerofObjectwithValue(FT2OutlinePointsSizeIndex, rcvr, gs->outline.n_points);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}


/*	high byte is module error, low is generic error */

EXPORT(sqInt)
primitiveModuleErrorCode(void)
{
	// FT2Plugin>>#primitiveModuleErrorCode
	sqInt _return_value;

	_return_value = positive32BitIntegerFor((FT_ERROR_MODULE(errorCode)));
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}


/*	Fill in the receiver's (a FT2Face object) fields
	from the address and fields of a newly opened FT_Face object. */

EXPORT(sqInt)
primitiveNewFaceFromFileAndIndex(void)
{
	// FT2Plugin>>#primitiveNewFaceFromFileAndIndex
	sqInt anInteger;
	size_t byteSize;
	FT_Face face;
	char *fontFilePath;
	sqInt rcvr;
	char translatedFilePath[1024];

	success(isBytes(stackValue(1)));
	fontFilePath = ((char *) (firstIndexableField(stackValue(1))));
	anInteger = stackIntegerValue(0);
	success(isKindOf(stackValue(2), "FT2Face"));
	rcvr = stackValue(2);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	;
	errorCode = 0;
	byteSize = byteSizeOf(((sqInt)(long)(fontFilePath) - 4));
	;
	if (failed()) {
		return null;
	}
	if (byteSize > 1000) {
success(0);
		return null;
	}
	ioFilenamefromStringofLengthresolveAliases(translatedFilePath, fontFilePath, byteSize, 1);
	errorCode = FT_New_Face(library, translatedFilePath, anInteger, &face);
	;
	;
	success(errorCode == 0);
	if (failed()) {
		return null;
	}
	ftAllocateHandleInReceiverForPointer(face);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(2);
	return null;
}


/*	Fill in the receiver's (a FT2Face object) fields
	from the address and fields of a newly opened FT_Face object. */

EXPORT(sqInt)
primitiveNewMemoryFaceFromExternalMemoryAndIndex(void)
{
	// FT2Plugin>>#primitiveNewMemoryFaceFromExternalMemoryAndIndex
	sqInt aFreeTypeExternalMemory;
	sqInt anInteger;
	sqInt byteSize;
	FT_Face face;
	void *memPointer;
	sqInt rcvr;

	aFreeTypeExternalMemory = stackValue(2);
	byteSize = stackIntegerValue(1);
	anInteger = stackIntegerValue(0);
	success(isKindOf(stackValue(3), "FT2Face"));
	rcvr = stackValue(3);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	;
	errorCode = 0;
	memPointer = ftHandleValueFromReceiver(aFreeTypeExternalMemory);
	;
	if (failed()) {
		return null;
	}
	errorCode = FT_New_Memory_Face(library, memPointer, byteSize, anInteger, &face);
	;
	;
	success(errorCode == 0);
	if (failed()) {
		return null;
	}
	ftAllocateHandleInReceiverForPointer(face);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(3);
	return null;
}


/*	Assumes that primitiveLoadGlyph:flags: has been called earlier to set
	face->glyph. 
 */

EXPORT(sqInt)
primitiveNumberOfOutlineCountours(void)
{
	// FT2Plugin>>#primitiveNumberOfOutlineCountours
	sqInt aFace;
	sqInt contoursSize;
	FT_Face face;
	FT_GlyphSlot gs;
	sqInt rcvr;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "FT2GlyphSlot"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	errorCode = 0;
	if ((slotSizeOf(rcvr)) < FT2GlyphSlotInstSize) {
		primitiveFail();
		return null;
	}
	aFace = fetchPointerofObject(FT2GlyphSlotFaceIndex, rcvr);
	face = ftHandleValueFromReceiver(aFace);
	if (face == null) {
primitiveFail();
		return null;
	}
	gs = face->glyph;
	if (!gs) {
primitiveFail();
		return null;
	}
	;
	contoursSize = gs->outline.n_contours;
	_return_value = integerObjectOf(contoursSize);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}


/*	Render this face into the given form */

EXPORT(sqInt)
primitiveRenderGlyphIntoForm(void)
{
	// FT2Plugin>>#primitiveRenderGlyphIntoForm
	FT_Bitmap bitmap;
	FT_Face face;
	sqInt faceOop;
	sqInt formOop;

	success(isKindOf(stackValue(0), "Form"));
	formOop = stackValue(0);
	success(isKindOf(stackValue(1), "FT2Face"));
	faceOop = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(faceOop);
	if (face == null) {
primitiveFail();
		return null;
	}
	ftInitBitmapfromForm(&bitmap, formOop);
	if (failed()) {
		return null;
	}
	errorCode = FT_Outline_Get_Bitmap(library, &face->glyph->outline, &bitmap);
	success(errorCode == 0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}


/*	Render this face into the given form */

EXPORT(sqInt)
primitiveRenderGlyphIntoFormWithRenderMode(void)
{
	// FT2Plugin>>#primitiveRenderGlyphIntoFormWithRenderMode
	FT_Bitmap bitmap;
	FT_Face face;
	sqInt faceOop;
	sqInt formOop;
	sqInt mode;

	success(isKindOf(stackValue(1), "Form"));
	formOop = stackValue(1);
	mode = stackIntegerValue(0);
	success(isKindOf(stackValue(2), "FT2Face"));
	faceOop = stackValue(2);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(faceOop);
	if (face == null) {
primitiveFail();
		return null;
	}
	ftInitBitmapfromFormrenderMode(&bitmap, formOop, mode);
	if (failed()) {
		return null;
	}
	errorCode = FT_Outline_Get_Bitmap(library, &face->glyph->outline, &bitmap);
	success(errorCode == 0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(2);
	return null;
}

EXPORT(sqInt)
primitiveResetErrorCode(void)
{
	// FT2Plugin>>#primitiveResetErrorCode
	sqInt oldError;
	sqInt _return_value;

	oldError = errorCode;
	errorCode = 0;
	_return_value = positive32BitIntegerFor(oldError);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}

EXPORT(sqInt)
primitiveSetFaceCharMap(void)
{
	// FT2Plugin>>#primitiveSetFaceCharMap
	FT_Encoding encoding;
	sqInt encodingString;
	FT_Face face;
	sqInt rcvr;

	encodingString = stackValue(0);
	success(isKindOf(stackValue(1), "FT2Face"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	encoding = ftEncodingValueFromString(encodingString);
	if (failed()) {
		return null;
	}
	;
	errorCode = FT_Select_Charmap(face, encoding);
	success(errorCode == 0);
	if (failed()) {
		return null;
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}

EXPORT(sqInt)
primitiveSetPixelSizes(void)
{
	// FT2Plugin>>#primitiveSetPixelSizes
	FT_Face face;
	sqInt rcvr;
	sqInt x;
	sqInt y;

	x = stackIntegerValue(1);
	y = stackIntegerValue(0);
	success(isKindOf(stackValue(2), "FT2Face"));
	rcvr = stackValue(2);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	errorCode = FT_Set_Pixel_Sizes(face, x, y);
	success(errorCode == 0);
	if (failed()) {
		return null;
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(2);
	return null;
}

EXPORT(sqInt)
primitiveSetTransform(void)
{
	// FT2Plugin>>#primitiveSetTransform
	FT_Vector delta;
	sqInt *deltasqIntPtr;
	sqInt deltaWordArray;
	FT_Face face;
	FT_Matrix matrix;
	sqInt *matrixsqIntPtr;
	sqInt matrixWordArray;
	sqInt rcvr;

	matrixWordArray = stackValue(1);
	deltaWordArray = stackValue(0);
	success(isKindOf(stackValue(2), "FT2Face"));
	rcvr = stackValue(2);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	matrixsqIntPtr = arrayValueOf(matrixWordArray);
	deltasqIntPtr = arrayValueOf(deltaWordArray);
	delta.x = deltasqIntPtr[0]; delta.y = deltasqIntPtr[1];;
	matrix.xx = matrixsqIntPtr[0]; matrix.xy = matrixsqIntPtr[1]; 
		matrix.yx = matrixsqIntPtr[2]; matrix.yy = matrixsqIntPtr[3]; ;
	if (!(failed())) {
		FT_Set_Transform( face, &matrix, &delta);
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(2);
	return null;
}

EXPORT(sqInt)
primitiveTransformFaceGlyphSlotOutline(void)
{
	// FT2Plugin>>#primitiveTransformFaceGlyphSlotOutline
	FT_Face face;
	FT_Matrix matrix;
	sqInt *matrixsqIntPtr;
	sqInt matrixWordArray;
	sqInt rcvr;

	matrixWordArray = stackValue(0);
	success(isKindOf(stackValue(1), "FT2Face"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	matrixsqIntPtr = arrayValueOf(matrixWordArray);
	matrix.xx = matrixsqIntPtr[0]; matrix.xy = matrixsqIntPtr[1]; 
		matrix.yx = matrixsqIntPtr[2]; matrix.yy = matrixsqIntPtr[3]; ;
	if (!(failed())) {
		FT_Outline_Transform( &face->glyph->outline, &matrix );
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}

EXPORT(sqInt)
primitiveTranslateFaceGlyphSlotOutline(void)
{
	// FT2Plugin>>#primitiveTranslateFaceGlyphSlotOutline
	FT_Vector delta;
	sqInt *deltasqIntPtr;
	sqInt deltaWordArray;
	FT_Face face;
	sqInt rcvr;

	deltaWordArray = stackValue(0);
	success(isKindOf(stackValue(1), "FT2Face"));
	rcvr = stackValue(1);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	face = ftHandleValueFromReceiver(rcvr);
	if (face == null) {
primitiveFail();
		return null;
	}
	deltasqIntPtr = arrayValueOf(deltaWordArray);
	delta.x = deltasqIntPtr[0]; delta.y = deltasqIntPtr[1];;
	if (!(failed())) {
		FT_Outline_Translate( &face->glyph->outline, delta.x, delta.y );
	}
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	pop(1);
	return null;
}

EXPORT(sqInt)
primitiveVersion(void)
{
	// FT2Plugin>>#primitiveVersion
	int amajor;
	int aminor;
	int apatch;
	sqInt rcvr;

	success(isKindOf(stackValue(0), "FT2Version"));
	rcvr = stackValue(0);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	errorCode = 0;
	FT_Library_Version(library, &amajor, &aminor, &apatch);
	;
	storeIntegerofObjectwithValue(0, rcvr, amajor);
	;
	storeIntegerofObjectwithValue(1, rcvr, aminor);
	;
	storeIntegerofObjectwithValue(2, rcvr, apatch);
	if (failed()) {
		/* begin ftParameterError */
errorCode = 255;
		primitiveFail();
		return null;
	}
	return null;
}


/*	Note: This is coded so that it can be run in Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
	// InterpreterPlugin>>#setInterpreter:
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {

#if !defined(SQUEAK_BUILTIN_PLUGIN)
		arrayValueOf = interpreterProxy->arrayValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
		classByteArray = interpreterProxy->classByteArray;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		fetchArrayofObject = interpreterProxy->fetchArrayofObject;
		fetchIntegerofObject = interpreterProxy->fetchIntegerofObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		ioFilenamefromStringofLengthresolveAliases = interpreterProxy->ioFilenamefromStringofLengthresolveAliases;
		isKindOf = interpreterProxy->isKindOf;
		isBytes = interpreterProxy->isBytes;
		isIndexable = interpreterProxy->isIndexable;
		isIntegerObject = interpreterProxy->isIntegerObject;
		isPointers = interpreterProxy->isPointers;
		isWords = interpreterProxy->isWords;
		makePointwithxValueyValue = interpreterProxy->makePointwithxValueyValue;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		nilObject = interpreterProxy->nilObject;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		primitiveFail = interpreterProxy->primitiveFail;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storeIntegerofObjectwithValue = interpreterProxy->storeIntegerofObjectwithValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		success = interpreterProxy->success;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

EXPORT(sqInt)
shutdownModule(void)
{
	// FT2Plugin>>#shutdownModule
	errorCode = FT_Done_FreeType(library);
	if (errorCode == 0) {
library = null;
	}
	return errorCode == 0;
}

static void
sqAssert(sqInt aBool)
{
	// SmartSyntaxInterpreterPlugin>>#sqAssert:
	/* missing DebugCode */;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* FT2Plugin_exports[][3] = {
	{"FT2Plugin", "getModuleName", (void*)getModuleName},
	{"FT2Plugin", "initialiseModule", (void*)initialiseModule},
	{"FT2Plugin", "primitiveCopyToExternalMemory", (void*)primitiveCopyToExternalMemory},
	{"FT2Plugin", "primitiveDoneFace", (void*)primitiveDoneFace},
	{"FT2Plugin", "primitiveDoneFacePreserveFields", (void*)primitiveDoneFacePreserveFields},
	{"FT2Plugin", "primitiveEmboldenFaceGlyphSlotOutline", (void*)primitiveEmboldenFaceGlyphSlotOutline},
	{"FT2Plugin", "primitiveErrorCode", (void*)primitiveErrorCode},
	{"FT2Plugin", "primitiveErrorString", (void*)primitiveErrorString},
	{"FT2Plugin", "primitiveFreeExternalMemory", (void*)primitiveFreeExternalMemory},
	{"FT2Plugin", "primitiveGetFaceCharIndex", (void*)primitiveGetFaceCharIndex},
	{"FT2Plugin", "primitiveGetFaceCharMap", (void*)primitiveGetFaceCharMap},
	{"FT2Plugin", "primitiveGetFaceCharMapsIntoArray", (void*)primitiveGetFaceCharMapsIntoArray},
	{"FT2Plugin", "primitiveGetFaceGlyphName", (void*)primitiveGetFaceGlyphName},
	{"FT2Plugin", "primitiveGetKerningLeftRight", (void*)primitiveGetKerningLeftRight},
	{"FT2Plugin", "primitiveGetPostscriptName", (void*)primitiveGetPostscriptName},
	{"FT2Plugin", "primitiveGetSfntTableOS2", (void*)primitiveGetSfntTableOS2},
	{"FT2Plugin", "primitiveHasKerning", (void*)primitiveHasKerning},
	{"FT2Plugin", "primitiveLibraryHandle", (void*)primitiveLibraryHandle},
	{"FT2Plugin", "primitiveLoadCharacter", (void*)primitiveLoadCharacter},
	{"FT2Plugin", "primitiveLoadFaceBbox", (void*)primitiveLoadFaceBbox},
	{"FT2Plugin", "primitiveLoadFaceFields", (void*)primitiveLoadFaceFields},
	{"FT2Plugin", "primitiveLoadGlyph", (void*)primitiveLoadGlyph},
	{"FT2Plugin", "primitiveLoadGlyphSlotFromFace", (void*)primitiveLoadGlyphSlotFromFace},
	{"FT2Plugin", "primitiveLoadOutlineArraysFromFace", (void*)primitiveLoadOutlineArraysFromFace},
	{"FT2Plugin", "primitiveLoadOutlineSizesFromFace", (void*)primitiveLoadOutlineSizesFromFace},
	{"FT2Plugin", "primitiveModuleErrorCode", (void*)primitiveModuleErrorCode},
	{"FT2Plugin", "primitiveNewFaceFromFileAndIndex", (void*)primitiveNewFaceFromFileAndIndex},
	{"FT2Plugin", "primitiveNewMemoryFaceFromExternalMemoryAndIndex", (void*)primitiveNewMemoryFaceFromExternalMemoryAndIndex},
	{"FT2Plugin", "primitiveNumberOfOutlineCountours", (void*)primitiveNumberOfOutlineCountours},
	{"FT2Plugin", "primitiveRenderGlyphIntoForm", (void*)primitiveRenderGlyphIntoForm},
	{"FT2Plugin", "primitiveRenderGlyphIntoFormWithRenderMode", (void*)primitiveRenderGlyphIntoFormWithRenderMode},
	{"FT2Plugin", "primitiveResetErrorCode", (void*)primitiveResetErrorCode},
	{"FT2Plugin", "primitiveSetFaceCharMap", (void*)primitiveSetFaceCharMap},
	{"FT2Plugin", "primitiveSetPixelSizes", (void*)primitiveSetPixelSizes},
	{"FT2Plugin", "primitiveSetTransform", (void*)primitiveSetTransform},
	{"FT2Plugin", "primitiveTransformFaceGlyphSlotOutline", (void*)primitiveTransformFaceGlyphSlotOutline},
	{"FT2Plugin", "primitiveTranslateFaceGlyphSlotOutline", (void*)primitiveTranslateFaceGlyphSlotOutline},
	{"FT2Plugin", "primitiveVersion", (void*)primitiveVersion},
	{"FT2Plugin", "setInterpreter", (void*)setInterpreter},
	{"FT2Plugin", "shutdownModule", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
